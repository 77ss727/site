<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>secure boot讲解</title>
    <link rel="stylesheet" href="复杂的.css">
    <link rel="icon" href="images/tubiao.png" type="image/x-icon">
</head>
<body>

    <h3 class="title1">secure boot</h3>
    <h2>主机厂干了什么？</h2>
    <p id="1">1 使用密钥生成工具，生成八对公钥私钥。</p>
    <p>2 | 8个公钥经过hash处理，将八个hash值放在一张表里</p>
    <p>3 计算表的hash值，存放在OTP中（一次性编程存储器，不能擦除和修改）。BSEC 可以理解为管理 OTP 的一种机制或控制器，进行对OTP内容的操作。</p>
    <p>4 签名，计算镜像的hash，签名工具将该哈希值用私钥签名（通过ECC算法————非对称加密，生成了一个签名），公钥和签名放入header中。</p>
    <p>5 将Hash Table存放在header中，可用公钥存放在header中。</p>
    


    
    <h2>Rom验证：</h2>
    <p>6 计算（哈希值表）的hash，与OTP中的PKHTH（公钥hash表的哈希）比较。验证我们的公钥hash表是没有被改变的，得到可信公钥hash表。</p>
    <p>7 计算header中可用公钥的hash（用什么公钥，验证哪个），与表中的hash比较，验证。如果相等，我们拿到了可信的公钥。</p>
    <p>8 使用可信公钥将签名进行解密，得到签名镜像的hash。</p>
    <p>9 计算header中FSBL的hash，与签名镜像的hash比较，如果相等，则镜像完整。</p>
    <img src="images/签名认证3.png" alt="签名认证" width="1058px">


    <h2>在原有的基础上加密解密</h2>
    <strong>加密 主机厂动作：</strong>
    <p>PS:加密解密主密钥，并非业务密钥，使用派生常数，派生加密解密密钥。（主密钥可以存储在HSM中避免明文暴露。）
        <br>PRF CMAC 派生是一种通过基于 CMAC 的伪随机函数从主密钥中派生多个密钥的技术。这种方法在许多加密协议中应用广泛，能够为密钥管理和安全通信提供强大的支持。通过合理地应用 CMAC 和 PRF，可以生成不可预测且安全的密钥，确保数据的保密性、完整性和认证。
    </p>
    <p>1 使用密钥生成工具生成加密解密主密钥，将加密解密主密钥存储在OTP中。</p>
    <p>2 加密解密主密钥根据派生常数，进行PRF CMAC派生，生成AES密钥（对称加密，加密解密密钥相同）。</p>
    <p>3 将FBSL的明文二进制文件计算hash，取哈希的128位最高有效值，将AES密钥的初始向量设置为128位最高有效值，加密FSBL明文得到FSBL文件存储在header中。</p>
    <p>4 将FSBL哈希128位最高有效值，派生常数存储在header中。</p>


    <strong>解密 ROM代码：</strong>
    <p>5 OTP中的加密解密主密钥根据派生常数，进行PRF CMAC派生得到AES密钥。</p>
    <p>6 AES密钥，使用header中的FSBL哈希128位最高有效位（作为初始向量），解密header中的FSBL加密文件，得到FSBL明文。</p>
    <p>7 将FSBL明文计算hash 与header中的FSBL哈希128位最高有效位进行比较，若相等，则镜像完整。
        （在镜像存储传输的过程中，还有可能因为自身原因，网络传输错误，媒介损坏，编码问题等出现错误，因此，更应进行镜像的验证。）</p>
    
    <img src="images/加密解密3.png" width="1058px">

    <h3 class="FBSL">FBSL-第一段引导加载程序</h3>
    <p></p>


</body>
</html>